diff --git a/bin/dune b/bin/dune
index fca70de..fd7f225 100644
--- a/bin/dune
+++ b/bin/dune
@@ -1,4 +1,4 @@
 (executable
  (public_name diffcessible)
  (name main)
- (libraries diffcessible cmdliner))
+ (libraries diffcessible cmdliner patch))
diff --git a/bin/main.ml b/bin/main.ml
index e03c4a4..cb71f31 100644
--- a/bin/main.ml
+++ b/bin/main.ml
@@ -1,7 +1,9 @@
 open Diffcessible
 
 let main () =
-  Interactive_viewer.start ()
+  let s = In_channel.input_all In_channel.stdin in
+  let patch = Patch.to_diffs s in
+  Interactive_viewer.start patch
 
 open Cmdliner
 
diff --git a/lib/dune b/lib/dune
index 196ed80..4269b32 100644
--- a/lib/dune
+++ b/lib/dune
@@ -1,3 +1,3 @@
 (library
  (name diffcessible)
- (libraries notty nottui lwd))
+ (libraries notty nottui lwd patch))
diff --git a/lib/interactive_viewer.ml b/lib/interactive_viewer.ml
index 9b59dfe..169ab52 100644
--- a/lib/interactive_viewer.ml
+++ b/lib/interactive_viewer.ml
@@ -1,39 +1,25 @@
 open Nottui
 module W = Nottui_widgets
-open Lwd_infix
-
-type patch = unit
+(* open Lwd_infix *)
 
 let pure_str s = Lwd.pure (W.string s)
-
-let string_of_counter c =
-  let$ c = c in
-  W.string (string_of_int c)
-
 let quit = Lwd.var false
-let counter = Lwd.var 0
-let counter_d = Lwd.get counter
+let string_of_operation = Format.asprintf "%a" (Patch.pp_operation ~git:false)
 
-let view =
+let view (patch : Patch.t list) =
+  let patch = match patch with p :: _ -> p | _ -> assert false in
   W.scrollbox
     (W.vbox
        [
-         pure_str "Hello world!";
-         string_of_counter counter_d;
+         pure_str (string_of_operation patch.operation);
          Lwd.pure
          @@ Ui.keyboard_area
               (function
                 | `ASCII 'q', [] ->
                     Lwd.set quit true;
                     `Handled
-                | `ASCII 'a', [] ->
-                    Lwd.set counter (Lwd.peek counter + 1);
-                    `Handled
-                | `ASCII 'b', [] ->
-                    Lwd.set counter (Lwd.peek counter - 1);
-                    `Handled
                 | _ -> `Unhandled)
               (W.string "Type 'q' to quit.");
        ])
 
-let start () = Ui_loop.run ~quit ~tick_period:0.2 view
+let start patch = Ui_loop.run ~quit ~tick_period:0.2 (view patch)
diff --git a/lib/interactive_viewer.mli b/lib/interactive_viewer.mli
index 1202346..1afff98 100644
--- a/lib/interactive_viewer.mli
+++ b/lib/interactive_viewer.mli
@@ -1,5 +1,3 @@
 (** Render and navigate through a diff. *)
 
-type patch = unit
-
-val start : patch -> unit
+val start : Patch.t list -> unit
diff --git a/vendor/patch/.github/workflows/main.yml b/vendor/patch/.github/workflows/main.yml
new file mode 100644
index 0000000..7e03ef2
--- /dev/null
+++ b/vendor/patch/.github/workflows/main.yml
@@ -0,0 +1,37 @@
+name: Main workflow
+
+on:
+  pull_request:
+  push:
+  schedule:
+    # Prime the caches every Monday
+    - cron: 0 1 * * MON
+
+jobs:
+  build:
+    strategy:
+      fail-fast: false
+      matrix:
+        os:
+          - macos-latest
+          - ubuntu-latest
+          - windows-latest
+        ocaml-compiler:
+          - 4.14.x
+
+    runs-on: ${{ matrix.os }}
+
+    steps:
+      - name: Checkout code
+        uses: actions/checkout@v2
+
+      - name: Use OCaml ${{ matrix.ocaml-compiler }}
+        uses: ocaml/setup-ocaml@v2
+        with:
+          ocaml-compiler: ${{ matrix.ocaml-compiler }}
+
+      - run: opam install . --deps-only --with-test
+
+      - run: opam exec -- dune build
+
+      - run: opam exec -- dune runtest
diff --git a/vendor/patch/.gitignore b/vendor/patch/.gitignore
new file mode 100644
index 0000000..6937a8f
--- /dev/null
+++ b/vendor/patch/.gitignore
@@ -0,0 +1,4 @@
+_build/
+.merlin
+*.install
+.*.swp
diff --git a/vendor/patch/CHANGES.md b/vendor/patch/CHANGES.md
new file mode 100644
index 0000000..4e305b0
--- /dev/null
+++ b/vendor/patch/CHANGES.md
@@ -0,0 +1,9 @@
+## v1.0.1 (2022-10-27)
+
+* Remove unnecessary bytes dependency
+* Fix compilation of examples
+* Use GitHub actions instead of travis
+
+## v1.0.0 (2019-12-21)
+
+* Initial public release
diff --git a/vendor/patch/LICENSE.md b/vendor/patch/LICENSE.md
new file mode 100644
index 0000000..cc6f43e
--- /dev/null
+++ b/vendor/patch/LICENSE.md
@@ -0,0 +1,16 @@
+(*
+ * Copyright (c) 2019 Hannes Mehnert <hannes@mehnert.org>
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ *)
diff --git a/vendor/patch/README.md b/vendor/patch/README.md
new file mode 100644
index 0000000..50bd4d1
--- /dev/null
+++ b/vendor/patch/README.md
@@ -0,0 +1,84 @@
+## Patch - apply your unified diffs in pure OCaml
+
+The loosely specified `diff` file format is widely used for transmitting
+differences of line-based information. The motivating example is
+[`opam`](https://opam.ocaml.org), which is able to validate updates being
+cryptographically signed (e.g. [conex](https://github.com/hannesm/conex)) by
+providing a unified diff.
+
+The [test-based infered specification](https://www.artima.com/weblogs/viewpost.jsp?thread=164293)
+implemented in this library is the following grammar.
+
+```
+decimal := [0-9]+
+any := any character except newline
+
+filename := "/dev/null" | any except tab character
+file := filename "\t" any "\n"
+mine := "--- " file
+theirs := "+++ " file
+
+no_newline = "\ No newline at end of file"
+hunk_line_prefix := " " | "-" | "+"
+hunk_line := hunk_line_prefix any | no_newline
+range := decimal "," decimal | decimal
+hunk_hdr := "@@ -" range " + " range " @@\n"
+hunk := hunk_hdr line+
+
+diff := mine theirs hunk+
+```
+
+In addition, some support for the git diff format is available, which contains
+`diff --git a/nn b/nn` as separator, prefixes filenames with `a/` and `b/`, and
+may contain extra headers, especially for pure renaming: `rename from <path>`
+followed by `rename to <path>`. The git diff documentation also mentions that a
+diff file itself should be an atomic operation, thus all `-` files corrspond to
+the files before applying the diff (since `patch` only does single diff
+operations, and requires the old content as input). You have to ensure to
+provide the correct data yourself.
+
+A `diff` consists of a two-line header containing the filenames (or "/dev/null"
+for creation and deletion) followed by the actual changes in hunks. A complete
+diff file is represented by a list of `diff` elements. The OCaml types below,
+provided by this library, represent mine and theirs as operation (edit, rename,
+delete, create). Since a diff is line-based, if the file does not end with a
+newline character, the line in the diff always contains a newline, but the
+special marker `no_newline` is added to the diff. The `range` information
+carries start line and chunk size in the respective file, with two side
+conditions: if the chunk size is 0, the start line refers to after which the
+chunk should be added or deleted, and if the chunk size is omitted (including
+the comma), it is set to 1. NB from practical experiments, only "+1" and "-1"
+are supported.
+
+```OCaml
+type operation =
+  | Edit of string
+  | Rename of string * string
+  | Delete of string
+  | Create of string
+  | Rename_only of string * string
+
+type hunk (* positions and contents *)
+
+type t = {
+  operation : operation ;
+  hunks : hunk list ;
+  mine_no_nl : bool ;
+  their_no_nl : bool ;
+}
+```
+
+## Shortcomings
+
+The function `patch` assumes that the patch applies cleanly, and does not
+check this assumption. Exceptions may be raised if this assumption is violated.
+The git diff format allows further features, such as file permissions, and also
+a "copy from / to" header, which I was unable to spot in the wild.
+
+## Installation
+
+`opam install patch`
+
+## Documentation
+
+The API documentation can be browsed [online](https://hannesm.github.io/patch/).
diff --git a/vendor/patch/dune-project b/vendor/patch/dune-project
new file mode 100644
index 0000000..662f237
--- /dev/null
+++ b/vendor/patch/dune-project
@@ -0,0 +1,2 @@
+(lang dune 1.0)
+(name patch)
diff --git a/vendor/patch/patch.opam b/vendor/patch/patch.opam
new file mode 100644
index 0000000..087e183
--- /dev/null
+++ b/vendor/patch/patch.opam
@@ -0,0 +1,25 @@
+opam-version: "2.0"
+maintainer: "Hannes Mehnert <hannes@mehnert.org>"
+authors: ["Hannes Mehnert <hannes@mehnert.org>"]
+homepage: "https://github.com/hannesm/patch"
+doc: "https://hannesm.github.io/patch/"
+dev-repo: "git+https://github.com/hannesm/patch.git"
+bug-reports: "https://github.com/hannesm/patch/issues"
+license: "ISC"
+
+depends: [
+  "ocaml" {>= "4.04.2"}
+  "dune"
+  "alcotest" {with-test}
+  "crowbar" {with-test}
+]
+build: [
+  ["dune" "subst"] {dev}
+  ["dune" "build" "-p" name "-j" jobs]
+  ["dune" "runtest" "-p" name "-j" jobs] {with-test}
+]
+synopsis: "Patch library purely in OCaml"
+description: """
+This is a library which parses unified diff and git diff output, and can
+apply a patch in memory.
+"""
diff --git a/vendor/patch/src/dune b/vendor/patch/src/dune
new file mode 100644
index 0000000..5598670
--- /dev/null
+++ b/vendor/patch/src/dune
@@ -0,0 +1,11 @@
+(library
+ (name patch)
+ (synopsis "Patch purely in OCaml")
+ (public_name patch)
+ (modules patch)
+ (wrapped false))
+
+(executable
+ (name patch_command)
+ (modules patch_command)
+ (libraries patch))
diff --git a/vendor/patch/src/patch.ml b/vendor/patch/src/patch.ml
new file mode 100644
index 0000000..d8e2041
--- /dev/null
+++ b/vendor/patch/src/patch.ml
@@ -0,0 +1,297 @@
+module String = struct
+  let is_prefix ~prefix str =
+    let pl = String.length prefix in
+    if String.length str < pl then
+      false
+    else
+      String.sub str 0 (String.length prefix) = prefix
+
+  let cut sep str =
+    try
+      let idx = String.index str sep
+      and l = String.length str
+      in
+      let sidx = succ idx in
+      Some (String.sub str 0 idx, String.sub str sidx (l - sidx))
+    with
+      Not_found -> None
+
+  let cuts sep str =
+    let rec doit acc s =
+      match cut sep s with
+      | None -> List.rev (s :: acc)
+      | Some (a, b) -> doit (a :: acc) b
+    in
+    doit [] str
+
+  let slice ?(start = 0) ?stop str =
+    let stop = match stop with
+      | None -> String.length str
+      | Some x -> x
+    in
+    let len = stop - start in
+    String.sub str start len
+
+  let trim = String.trim
+
+  let get = String.get
+
+  let concat = String.concat
+
+  let length = String.length
+
+  let equal = String.equal
+end
+
+type hunk = {
+  mine_start : int ;
+  mine_len : int ;
+  mine : string list ;
+  their_start : int ;
+  their_len : int ;
+  their : string list ;
+}
+
+let unified_diff hunk =
+  (* TODO *)
+  String.concat "\n" (List.map (fun line -> "-" ^ line) hunk.mine @
+                      List.map (fun line -> "+" ^ line) hunk.their)
+
+let pp_hunk ppf hunk =
+  Format.fprintf ppf "@@@@ -%d,%d +%d,%d @@@@\n%s"
+    hunk.mine_start hunk.mine_len hunk.their_start hunk.their_len
+    (unified_diff hunk)
+
+let take data num =
+  let rec take0 num data acc =
+    match num, data with
+    | 0, _ -> List.rev acc
+    | n, x::xs -> take0 (pred n) xs (x :: acc)
+    | _ -> invalid_arg "take0 broken"
+  in
+  take0 num data []
+
+let drop data num =
+  let rec drop data num =
+    match num, data with
+    | 0, _ -> data
+    | n, _::xs -> drop xs (pred n)
+    | _ -> invalid_arg "drop broken"
+  in
+  try drop data num with
+  | Invalid_argument _ -> invalid_arg ("drop " ^ string_of_int num ^ " on " ^ string_of_int (List.length data))
+
+(* TODO verify that it applies cleanly *)
+let apply_hunk old (index, to_build) hunk =
+  try
+    let prefix = take (drop old index) (hunk.mine_start - index) in
+    (hunk.mine_start + hunk.mine_len, to_build @ prefix @ hunk.their)
+  with
+  | Invalid_argument _ -> invalid_arg ("apply_hunk " ^ string_of_int index ^ " old len " ^ string_of_int (List.length old) ^
+                                       " hunk start " ^ string_of_int hunk.mine_start ^ " hunk len " ^ string_of_int hunk.mine_len)
+
+let to_start_len data =
+  (* input being "?19,23" *)
+  match String.cut ',' (String.slice ~start:1 data) with
+  | None when data = "+1" || data = "-1" -> (0, 1)
+  | None -> invalid_arg ("start_len broken in " ^ data)
+  | Some (start, len) ->
+     let len = int_of_string len
+     and start = int_of_string start
+     in
+     let st = if len = 0 || start = 0 then start else pred start in
+     (st, len)
+
+let count_to_sl_sl data =
+  if String.is_prefix ~prefix:"@@" data then
+    (* input: "@@ -19,23 +19,12 @@ bla" *)
+    (* output: ((19,23), (19, 12)) *)
+    match List.filter (function "" -> false | _ -> true) (String.cuts '@' data) with
+    | numbers::_ ->
+       let nums = String.trim numbers in
+       (match String.cut ' ' nums with
+        | None -> invalid_arg "couldn't find space in count"
+        | Some (mine, theirs) -> Some (to_start_len mine, to_start_len theirs))
+    | _ -> invalid_arg "broken line!"
+  else
+    None
+
+let sort_into_bags dir mine their m_nl t_nl str =
+  if String.length str = 0 then
+    None
+  else if String.is_prefix ~prefix:"---" str then
+    None
+  else match String.get str 0, String.slice ~start:1 str with
+    | ' ', data -> Some (`Both, (data :: mine), (data :: their), m_nl, t_nl)
+    | '+', data -> Some (`Their, mine, (data :: their), m_nl, t_nl)
+    | '-', data -> Some (`Mine, (data :: mine), their, m_nl, t_nl)
+    | '\\', data ->
+      (* diff: 'No newline at end of file' turns out to be context-sensitive *)
+      (* so: -xxx\n\\No newline... means mine didn't have a newline *)
+      (* but +xxx\n\\No newline... means theirs doesn't have a newline *)
+      assert (data = " No newline at end of file");
+      let my_nl, their_nl = match dir with
+        | `Both -> true, true
+        | `Mine -> true, t_nl
+        | `Their -> m_nl, true
+      in
+      Some (dir, mine, their, my_nl, their_nl)
+    | _ -> None
+
+let to_hunk count data mine_no_nl their_no_nl =
+  match count_to_sl_sl count with
+  | None -> None, mine_no_nl, their_no_nl, count :: data
+  | Some ((mine_start, mine_len), (their_start, their_len)) ->
+    let rec step dir mine their mine_no_nl their_no_nl = function
+      | [] -> (List.rev mine, List.rev their, mine_no_nl, their_no_nl, [])
+      | x::xs -> match sort_into_bags dir mine their mine_no_nl their_no_nl x with
+        | Some (dir, mine, their, mine_no_nl', their_no_nl') -> step dir mine their mine_no_nl' their_no_nl' xs
+        | None -> (List.rev mine, List.rev their, mine_no_nl, their_no_nl, x :: xs)
+    in
+    let mine, their, mine_no_nl, their_no_nl, rest = step `Both [] [] mine_no_nl their_no_nl data in
+    (Some { mine_start ; mine_len ; mine ; their_start ; their_len ; their }, mine_no_nl, their_no_nl, rest)
+
+let rec to_hunks (mine_no_nl, their_no_nl, acc) = function
+  | [] -> (List.rev acc, mine_no_nl, their_no_nl, [])
+  | count::data -> match to_hunk count data mine_no_nl their_no_nl with
+    | None, mine_no_nl, their_no_nl, rest -> List.rev acc, mine_no_nl, their_no_nl, rest
+    | Some hunk, mine_no_nl, their_no_nl, rest -> to_hunks (mine_no_nl, their_no_nl, hunk :: acc) rest
+
+type operation =
+  | Edit of string
+  | Rename of string * string
+  | Delete of string
+  | Create of string
+  | Rename_only of string * string
+
+let operation_eq a b = match a, b with
+  | Edit a, Edit b
+  | Delete a, Delete b
+  | Create a, Create b -> String.equal a b
+  | Rename (a, a'), Rename (b, b')
+  | Rename_only (a, a'), Rename_only (b, b') -> String.equal a b && String.equal a' b'
+  | _ -> false
+
+let no_file = "/dev/null"
+
+let pp_operation ~git ppf op =
+  let real_name direction name =
+    if git then name else
+      match direction with `Mine -> "a/" ^ name | `Theirs -> "b/" ^ name
+  in
+  let hdr mine their =
+    (* even if create/delete, /dev/null is not used in this header *)
+    (* according to git documentation *)
+    if git then
+      Format.fprintf ppf "diff --git %s %s\n"
+        (real_name `Mine mine) (real_name `Theirs their)
+  in
+  match op with
+  | Edit name ->
+    hdr name name ;
+    Format.fprintf ppf "--- %s\n" (real_name `Mine name) ;
+    Format.fprintf ppf "+++ %s\n" (real_name `Theirs name)
+  | Rename (old_name, new_name) ->
+    hdr old_name new_name ;
+    Format.fprintf ppf "--- %s\n" (real_name `Mine old_name) ;
+    Format.fprintf ppf "+++ %s\n" (real_name `Theirs new_name)
+  | Delete name ->
+    hdr name name ;
+    Format.fprintf ppf "--- %s\n" (real_name `Mine name) ;
+    Format.fprintf ppf "+++ %s\n" no_file
+  | Create name ->
+    hdr name name ;
+    Format.fprintf ppf "--- %s\n" no_file ;
+    Format.fprintf ppf "+++ %s\n" (real_name `Theirs name)
+  | Rename_only (old_name, new_name) ->
+    hdr old_name new_name ;
+    Format.fprintf ppf "rename from %s\n" old_name;
+    Format.fprintf ppf "rename to %s\n" new_name
+
+type t = {
+  operation : operation ;
+  hunks : hunk list ;
+  mine_no_nl : bool ;
+  their_no_nl : bool ;
+}
+
+let pp ~git ppf t =
+  pp_operation ~git ppf t.operation ;
+  List.iter (pp_hunk ppf) t.hunks
+
+let operation_of_strings git mine their =
+  let get_filename_opt n =
+    let s = match String.cut '\t' n with None -> n | Some (x, _) -> x in
+    if s = no_file then None else
+    if git && (String.is_prefix ~prefix:"a/" s || String.is_prefix ~prefix:"b/" s) then
+      Some (String.slice ~start:2 s)
+    else Some s
+  in
+  match get_filename_opt mine, get_filename_opt their with
+  | None, Some n -> Create n
+  | Some n, None -> Delete n
+  | Some a, Some b -> if String.equal a b then Edit a else Rename (a, b)
+  | None, None -> assert false (* ??!?? *)
+
+(* parses a list of lines to a diff.t list *)
+let to_diff data =
+  (* first locate --- and +++ lines *)
+  let rec find_start git ?hdr = function
+    | [] -> hdr, []
+    | x::xs when String.is_prefix ~prefix:"diff --git" x ->
+      begin match hdr with None -> find_start true xs | Some _ -> hdr, x::xs end
+    | x::y::xs when String.is_prefix ~prefix:"rename from" x && String.is_prefix ~prefix:"rename to" y ->
+      let hdr = Rename_only (String.slice ~start:12 x, String.slice ~start:10 y) in
+      find_start git ~hdr xs
+    | x::y::xs when String.is_prefix ~prefix:"---" x ->
+      let mine = String.slice ~start:4 x and their = String.slice ~start:4 y in
+      Some (operation_of_strings git mine their), xs
+    | _::xs -> find_start git ?hdr xs
+  in
+  match find_start false data with
+  | Some (Rename_only _ as operation), rest ->
+    let hunks = [] and mine_no_nl = false and their_no_nl = false in
+    Some ({ operation ; hunks ; mine_no_nl ; their_no_nl }, rest)
+  | Some operation, rest ->
+    let hunks, mine_no_nl, their_no_nl, rest = to_hunks (false, false, []) rest in
+    Some ({ operation ; hunks ; mine_no_nl ; their_no_nl }, rest)
+  | None, [] -> None
+  | None, _ -> assert false
+
+let to_lines = String.cuts '\n'
+
+let to_diffs data =
+  let lines = to_lines data in
+  let rec doit acc = function
+    | [] -> List.rev acc
+    | xs -> match to_diff xs with
+      | None -> List.rev acc
+      | Some (diff, rest) -> doit (diff :: acc) rest
+  in
+  doit [] lines
+
+let patch filedata diff =
+  match diff.operation with
+  | Rename_only _ -> filedata
+  | Delete _ -> None
+  | Create _ ->
+    begin match diff.hunks with
+      | [ the_hunk ] ->
+        let d = the_hunk.their in
+        let lines = if diff.their_no_nl then d else d @ [""] in
+        Some (String.concat "\n" lines)
+      | _ -> assert false
+    end
+  | _ ->
+    let old = match filedata with None -> [] | Some x -> to_lines x in
+    let idx, lines = List.fold_left (apply_hunk old) (0, []) diff.hunks in
+    let lines = lines @ drop old idx in
+    let lines =
+      match diff.mine_no_nl, diff.their_no_nl with
+      | false, true -> (match List.rev lines with ""::tl -> List.rev tl | _ -> lines)
+      | true, false -> lines @ [ "" ]
+      | false, false when filedata = None -> lines @ [ "" ]
+      | false, false -> lines
+      | true, true -> lines
+    in
+    Some (String.concat "\n" lines)
diff --git a/vendor/patch/src/patch.mli b/vendor/patch/src/patch.mli
new file mode 100644
index 0000000..4109785
--- /dev/null
+++ b/vendor/patch/src/patch.mli
@@ -0,0 +1,34 @@
+type hunk = {
+  mine_start : int ;
+  mine_len : int ;
+  mine : string list ;
+  their_start : int ;
+  their_len : int ;
+  their : string list ;
+}
+
+val pp_hunk : Format.formatter -> hunk -> unit
+
+type operation =
+  | Edit of string
+  | Rename of string * string
+  | Delete of string
+  | Create of string
+  | Rename_only of string * string
+
+val pp_operation : git:bool -> Format.formatter -> operation -> unit
+
+val operation_eq : operation -> operation -> bool
+
+type t = {
+  operation : operation ;
+  hunks : hunk list ;
+  mine_no_nl : bool ;
+  their_no_nl : bool ;
+}
+
+val pp : git:bool -> Format.formatter -> t -> unit
+
+val to_diffs : string -> t list
+
+val patch : string option -> t -> string option
diff --git a/vendor/patch/src/patch_command.ml b/vendor/patch/src/patch_command.ml
new file mode 100644
index 0000000..5a8651a
--- /dev/null
+++ b/vendor/patch/src/patch_command.ml
@@ -0,0 +1,88 @@
+(** For now this command is only used for testing,
+    in particular it is not installed to the user.
+    (If we wanted to install it, it would need
+    a better name.)
+*)
+
+let usage =
+  "Simplified patch utility for single-file patches;\n
+   ./patch.exe <input-file> <unififed-diff-file> -o <output-file>"
+
+let exit_command_line_error = 1
+let exit_open_error = 2
+let exit_several_chunks = 3
+let exit_patch_failure = 4
+
+let run ~input ~diff =
+  match Patch.to_diffs diff with
+  | [] -> input
+  | _::_::_ ->
+    prerr_endline "Error: The diff contains several chunks,\n\
+                   which is not supported by this command.";
+    exit exit_several_chunks
+  | [diff] ->
+    begin match Patch.patch (Some input) diff with
+    | None ->
+      Printf.eprintf "Error during patching:\n%!";
+      exit exit_patch_failure
+    | Some output -> output
+    end
+
+module IO = struct
+  let read input =
+    let rec loop buf input =
+      match input_char input with
+      | exception End_of_file -> Buffer.contents buf
+      | c -> Buffer.add_char buf c; loop buf input
+    in
+    loop (Buffer.create 80) input
+
+  let write output data =
+    String.iter (output_char output) data;
+    flush output;
+    ()
+end
+
+let () =
+  if Array.length Sys.argv = 1 then begin
+    prerr_endline usage;
+    exit 0;
+  end;
+  let input_path, diff_path, output_path = try
+      let input_path = Sys.argv.(1) in
+      let diff_path = Sys.argv.(2) in
+      let dash_o = Sys.argv.(3) in
+      let output_path = Sys.argv.(4) in
+      if dash_o <> "-o" then raise Exit;
+      input_path,
+      diff_path,
+      output_path
+    with _ ->
+      prerr_endline "Error parsing the command-line arguments";
+      prerr_endline usage;
+      prerr_newline ();
+      exit exit_command_line_error
+  in
+  let get_data path =
+    match open_in path with
+    | exception _ ->
+      Printf.eprintf "Error: unable to open file %S for reading\n%!" path;
+      exit exit_open_error
+    | input ->
+      let data = IO.read input in
+      close_in input;
+      data
+  in
+  let write_data path ~data =
+    match open_out path with
+    | exception _ ->
+      Printf.eprintf "Error: unable to open file %S for writing\n%!" path;
+      exit exit_open_error
+    | output ->
+      IO.write output data;
+      close_out output
+  in
+  let input_data = get_data input_path in
+  let diff_data = get_data diff_path in
+  let output_data = run ~input:input_data ~diff:diff_data in
+  write_data output_path ~data:output_data
diff --git a/vendor/patch/test/crowbar_test.ml b/vendor/patch/test/crowbar_test.ml
new file mode 100644
index 0000000..2756f94
--- /dev/null
+++ b/vendor/patch/test/crowbar_test.ml
@@ -0,0 +1,159 @@
+(** USAGE:
+
+    This test works by generating two files (source and target),
+    diffing them using the system `diff -u` command,
+    applying our Patch code to the source file,
+    and checking that we get the target back.
+
+    Counter-examples will give you the source and target file.
+
+    From the root repository, run
+
+       dune exec test/crowbar_test.exe
+
+    to get quicheck-like (blackbox) fuzzing, and
+
+       mkdir -p /tmp/input
+       mkdir -p /tmp/output
+       echo foo > /tmp/input/test
+       dune build test/crowbar_test.exe
+       afl-fuzz -i /tmp/input -o /tmp/output dune exec test/crowbar_test.exe @@
+
+    for AFL-full (greybox) fuzzing.
+
+    If you find a counter-example, you can use src/patch_command
+    to reproduce the issue. For example, if the quickcheck mode tells you:
+
+    > patch: ....
+    > patch: FAIL
+    >
+    > When given the input:
+    >
+    >     ["\nx"; "\n"]
+    >
+    > the test failed:
+    >
+    >     "" != "\n"
+    >
+
+    You can run
+
+      echo -n -e "\nx" > file1
+      echo -n -e "\n" > file2
+      diff -u file1 file2 > diff
+      patch file1 diff -o file2-std-patch
+      dune exec src/patch_command.exe -- file1 diff -o file2-our-patch
+      diff file2-our-patch file2-std-patch
+      rm file1 file2 diff file2-std-patch file2-our-patch
+
+    to check for yourself.
+*)
+
+
+type line = string
+type file = line list
+
+let string_of_file = String.concat ""
+
+module Printer = struct
+  open Crowbar
+  let line : line printer =
+    fun ppf line -> pp ppf "%S" line
+  let file : file printer =
+    fun ppf file -> pp ppf "%S" (String.concat "" file)
+end
+
+module Gen = struct
+  open Crowbar
+  let char : string gen =
+    map [range 25] (fun n -> String.make 1 (char_of_int (int_of_char 'a' + n)))
+  let line : line gen =
+    with_printer Printer.line @@
+    map [list char] (fun s -> String.concat "" (s @ ["\n"]))
+  let line_no_eol : line gen =
+    with_printer Printer.line @@
+    map [list char] (fun s -> String.concat "" s)
+  let file : file gen =
+    with_printer Printer.file @@
+    choose [
+      list line;
+      map [list line; line_no_eol] (fun lines line -> lines @ [line]);
+    ]
+end
+
+module IO = struct
+  let read input =
+    let rec loop buf acc input =
+      match input_char input with
+      | exception End_of_file ->
+        if Buffer.length buf = 0 then List.rev acc
+        else List.rev (Buffer.contents buf :: acc)
+      | '\n' ->
+        Buffer.add_char buf '\n';
+        let line = Buffer.contents buf in
+        Buffer.clear buf;
+        loop buf (line :: acc) input
+      | c ->
+        Buffer.add_char buf c;
+        loop buf acc input
+    in
+    loop (Buffer.create 80) [] input
+
+  let write output file =
+    List.iter (output_string output) file;
+    ()
+
+  let with_file_out file k =
+    let (path, oc) = Filename.open_temp_file "patch_crowbar" "" in
+    let clean () =
+      close_out oc;
+      Sys.remove path in
+    write oc file;
+    flush oc;
+    match k path with
+    | exception exn -> clean (); raise exn
+    | res -> clean (); res
+
+  let with_tmp k =
+    let path = Filename.temp_file "patch_crowbar_diff" "" in
+    let clean () = Sys.remove path in
+    match k path with
+    | exception exn -> clean (); raise exn
+    | res -> clean (); res
+end
+
+(** getting a system *diff* from two files *)
+let get_diffs (file1 : file) (file2 : file) : file =
+  IO.with_file_out file1 @@ fun path1 ->
+  IO.with_file_out file2 @@ fun path2 ->
+  IO.with_tmp @@ fun path_out ->
+  Printf.ksprintf (fun cmd -> ignore (Sys.command cmd))
+    "diff -u %S %S > %S" path1 path2 path_out;
+  let input = open_in path_out in
+  let res = IO.read input in
+  close_in input;
+  res
+
+let check_Patch file1 file2 =
+  let text_diff = string_of_file (get_diffs file1 file2) in
+  match Patch.to_diffs text_diff with
+  | [] -> Crowbar.check_eq (string_of_file file1) (string_of_file file2)
+  | _::_::_ -> Crowbar.fail "not a single diff!"
+  | [diff] ->
+    let data = string_of_file file1 in
+    match Patch.patch (Some data) diff with
+    | None ->
+      let exp = string_of_file file2 in
+      Crowbar.fail ("input file\n" ^ data ^ "\ndiff\n" ^ text_diff ^ "\nexpected\n" ^ exp)
+    | Some output ->
+      let exp = string_of_file file2 in
+      if String.equal exp output then
+        Crowbar.check_eq
+          ~pp:Crowbar.pp_string
+          output exp
+      else
+        Crowbar.fail ("input fileFFF\n" ^ data ^ "FFF\ndiffFFF\n" ^ text_diff ^ "FFF\nexpectedFFF\n" ^ exp ^ "FFF")
+
+
+let () =
+  Crowbar.(add_test ~name:"patch" [Gen.file; Gen.file] check_Patch)
diff --git a/vendor/patch/test/data/create1.diff b/vendor/patch/test/data/create1.diff
new file mode 100644
index 0000000..d61c4e0
--- /dev/null
+++ b/vendor/patch/test/data/create1.diff
@@ -0,0 +1,4 @@
+--- /dev/null
++++ a/create1
+@@ -0,0 +1 @@
++foo
diff --git a/vendor/patch/test/data/create1.new b/vendor/patch/test/data/create1.new
new file mode 100644
index 0000000..257cc56
--- /dev/null
+++ b/vendor/patch/test/data/create1.new
@@ -0,0 +1 @@
+foo
diff --git a/vendor/patch/test/data/crowbar1.diff b/vendor/patch/test/data/crowbar1.diff
new file mode 100644
index 0000000..a2d69bc
--- /dev/null
+++ b/vendor/patch/test/data/crowbar1.diff
@@ -0,0 +1,6 @@
+--- crowbar1.old
++++ crowbar1.new
+@@ -1,2 +1 @@
+ 
+-x
+\ No newline at end of file
diff --git a/vendor/patch/test/data/crowbar1.new b/vendor/patch/test/data/crowbar1.new
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/vendor/patch/test/data/crowbar1.new
@@ -0,0 +1 @@
+
diff --git a/vendor/patch/test/data/crowbar1.old b/vendor/patch/test/data/crowbar1.old
new file mode 100644
index 0000000..88ae695
--- /dev/null
+++ b/vendor/patch/test/data/crowbar1.old
@@ -0,0 +1,2 @@
+
+x
\ No newline at end of file
diff --git a/vendor/patch/test/data/first.diff b/vendor/patch/test/data/first.diff
new file mode 100644
index 0000000..35a4604
--- /dev/null
+++ b/vendor/patch/test/data/first.diff
@@ -0,0 +1,30 @@
+--- first.old	2019-03-10 19:09:28.825116000 +0100
++++ first.new	2019-03-10 19:09:36.053702000 +0100
+@@ -1,6 +1,7 @@
+ foo
+ foo
+ foo
++foo3
+ foo
+ foo
+ foo
+@@ -9,6 +10,7 @@
+ foo
+ foo
+ foo
++foo5
+ foo
+ foo
+ foo
+@@ -31,6 +33,11 @@
+ foo
+ foo
+ foo
++bar
+ foo
+ foo
+ foo
++foo
++foo
++foo
++bar2
diff --git a/vendor/patch/test/data/first.new b/vendor/patch/test/data/first.new
new file mode 100644
index 0000000..0bbe312
--- /dev/null
+++ b/vendor/patch/test/data/first.new
@@ -0,0 +1,43 @@
+foo
+foo
+foo
+foo3
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo5
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+bar
+foo
+foo
+foo
+foo
+foo
+foo
+bar2
diff --git a/vendor/patch/test/data/first.old b/vendor/patch/test/data/first.old
new file mode 100644
index 0000000..77617d8
--- /dev/null
+++ b/vendor/patch/test/data/first.old
@@ -0,0 +1,36 @@
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
diff --git a/vendor/patch/test/data/git1.diff b/vendor/patch/test/data/git1.diff
new file mode 100644
index 0000000..6d84dd7
--- /dev/null
+++ b/vendor/patch/test/data/git1.diff
@@ -0,0 +1,7 @@
+diff --git a/git1.new b/git1.new
+new file mode 100644
+index 0000000..257cc56
+--- /dev/null
++++ b/git1.new
+@@ -0,0 +1 @@
++foo
diff --git a/vendor/patch/test/data/git1.new b/vendor/patch/test/data/git1.new
new file mode 100644
index 0000000..257cc56
--- /dev/null
+++ b/vendor/patch/test/data/git1.new
@@ -0,0 +1 @@
+foo
diff --git a/vendor/patch/test/data/git2.diff b/vendor/patch/test/data/git2.diff
new file mode 100644
index 0000000..b98d8b3
--- /dev/null
+++ b/vendor/patch/test/data/git2.diff
@@ -0,0 +1,4 @@
+diff --git a/git2.old b/git2.new
+similarity index 100%
+rename from git2.old
+rename to git2.new
diff --git a/vendor/patch/test/data/git2.new b/vendor/patch/test/data/git2.new
new file mode 100644
index 0000000..257cc56
--- /dev/null
+++ b/vendor/patch/test/data/git2.new
@@ -0,0 +1 @@
+foo
diff --git a/vendor/patch/test/data/git2.old b/vendor/patch/test/data/git2.old
new file mode 100644
index 0000000..257cc56
--- /dev/null
+++ b/vendor/patch/test/data/git2.old
@@ -0,0 +1 @@
+foo
diff --git a/vendor/patch/test/data/git3.diff b/vendor/patch/test/data/git3.diff
new file mode 100644
index 0000000..97452d1
--- /dev/null
+++ b/vendor/patch/test/data/git3.diff
@@ -0,0 +1,10 @@
+diff --git a/git3.old b/git3.new
+similarity index 50%
+rename from a
+rename to c
+index 257cc56..3bd1f0e 100644
+--- a/git3.old
++++ b/git3.new
+@@ -1 +1,2 @@
+ foo
++bar
diff --git a/vendor/patch/test/data/git3.new b/vendor/patch/test/data/git3.new
new file mode 100644
index 0000000..3bd1f0e
--- /dev/null
+++ b/vendor/patch/test/data/git3.new
@@ -0,0 +1,2 @@
+foo
+bar
diff --git a/vendor/patch/test/data/git3.old b/vendor/patch/test/data/git3.old
new file mode 100644
index 0000000..257cc56
--- /dev/null
+++ b/vendor/patch/test/data/git3.old
@@ -0,0 +1 @@
+foo
diff --git a/vendor/patch/test/data/git4.diff b/vendor/patch/test/data/git4.diff
new file mode 100644
index 0000000..a11e7a1
--- /dev/null
+++ b/vendor/patch/test/data/git4.diff
@@ -0,0 +1,7 @@
+diff --git a/git4.old b/git4.old
+deleted file mode 100644
+index 257cc56..0000000
+--- a/git4.old
++++ /dev/null
+@@ -1 +0,0 @@
+-foo
diff --git a/vendor/patch/test/data/no-newline.diff b/vendor/patch/test/data/no-newline.diff
new file mode 100644
index 0000000..bc4ab33
--- /dev/null
+++ b/vendor/patch/test/data/no-newline.diff
@@ -0,0 +1,6 @@
+--- no-newline.old	2019-04-19 23:30:16.195504000 +0200
++++ no-newline.new	2019-04-19 23:30:27.421032000 +0200
+@@ -1 +1 @@
+-aaa
+\ No newline at end of file
++aaa
diff --git a/vendor/patch/test/data/no-newline.new b/vendor/patch/test/data/no-newline.new
new file mode 100644
index 0000000..72943a1
--- /dev/null
+++ b/vendor/patch/test/data/no-newline.new
@@ -0,0 +1 @@
+aaa
diff --git a/vendor/patch/test/data/no-newline.old b/vendor/patch/test/data/no-newline.old
new file mode 100644
index 0000000..7c4a013
--- /dev/null
+++ b/vendor/patch/test/data/no-newline.old
@@ -0,0 +1 @@
+aaa
\ No newline at end of file
diff --git a/vendor/patch/test/data/no-newline2.diff b/vendor/patch/test/data/no-newline2.diff
new file mode 100644
index 0000000..075c294
--- /dev/null
+++ b/vendor/patch/test/data/no-newline2.diff
@@ -0,0 +1,8 @@
+--- no-newline2.old	2019-04-19 23:31:27.578096000 +0200
++++ no-newline2.new	2019-04-19 23:31:33.404503000 +0200
+@@ -1 +1,2 @@
+-aaa
+\ No newline at end of file
++aaa
++bbb
+\ No newline at end of file
diff --git a/vendor/patch/test/data/no-newline2.new b/vendor/patch/test/data/no-newline2.new
new file mode 100644
index 0000000..d39cda9
--- /dev/null
+++ b/vendor/patch/test/data/no-newline2.new
@@ -0,0 +1,2 @@
+aaa
+bbb
\ No newline at end of file
diff --git a/vendor/patch/test/data/no-newline2.old b/vendor/patch/test/data/no-newline2.old
new file mode 100644
index 0000000..7c4a013
--- /dev/null
+++ b/vendor/patch/test/data/no-newline2.old
@@ -0,0 +1 @@
+aaa
\ No newline at end of file
diff --git a/vendor/patch/test/data/no-newline3.diff b/vendor/patch/test/data/no-newline3.diff
new file mode 100644
index 0000000..de09f22
--- /dev/null
+++ b/vendor/patch/test/data/no-newline3.diff
@@ -0,0 +1,6 @@
+--- no-newline3.old	2019-04-19 23:31:58.216807000 +0200
++++ no-newline3.new	2019-04-19 23:32:02.923740000 +0200
+@@ -1 +1 @@
+-aaa
++aaa
+\ No newline at end of file
diff --git a/vendor/patch/test/data/no-newline3.new b/vendor/patch/test/data/no-newline3.new
new file mode 100644
index 0000000..7c4a013
--- /dev/null
+++ b/vendor/patch/test/data/no-newline3.new
@@ -0,0 +1 @@
+aaa
\ No newline at end of file
diff --git a/vendor/patch/test/data/no-newline3.old b/vendor/patch/test/data/no-newline3.old
new file mode 100644
index 0000000..72943a1
--- /dev/null
+++ b/vendor/patch/test/data/no-newline3.old
@@ -0,0 +1 @@
+aaa
diff --git a/vendor/patch/test/dune b/vendor/patch/test/dune
new file mode 100644
index 0000000..a4c24d1
--- /dev/null
+++ b/vendor/patch/test/dune
@@ -0,0 +1,14 @@
+(executable
+ (name test)
+ (modules test)
+ (libraries patch alcotest))
+
+(alias
+ (name runtest)
+ (deps (source_tree data) (:< test.exe))
+ (action (run %{<})))
+
+(executable
+ (name crowbar_test)
+ (modules crowbar_test)
+ (libraries patch crowbar))
diff --git a/vendor/patch/test/test.ml b/vendor/patch/test/test.ml
new file mode 100644
index 0000000..3b7560e
--- /dev/null
+++ b/vendor/patch/test/test.ml
@@ -0,0 +1,464 @@
+
+let hunk_eq a b =
+  let open Patch in
+  a.mine_start = b.mine_start &&
+  a.mine_len = b.mine_len &&
+  a.their_start = b.their_start &&
+  a.their_len = b.their_len &&
+  List.length a.mine = List.length b.mine &&
+  List.length a.their = List.length b.their &&
+  List.for_all (fun x -> List.mem x b.mine) a.mine &&
+  List.for_all (fun x -> List.mem x b.their) a.their
+
+let test_hunk = Alcotest.testable Patch.pp_hunk hunk_eq
+
+let patch_eq a b =
+  let open Patch in
+  operation_eq a.operation b.operation &&
+  List.length a.hunks = List.length b.hunks &&
+  List.for_all (fun h -> List.exists (fun h' -> hunk_eq h h') b.hunks) a.hunks
+
+let test_t = Alcotest.testable (Patch.pp ~git:false) patch_eq
+
+let basic_files = [
+  Some "foo\n" ;
+  Some {|foo
+bar
+baz
+boo
+foo
+bar
+baz
+boo
+|} ;
+  Some {|foo
+bar
+baz
+boo
+foo
+bar
+bar
+boo
+foo
+bar
+baz
+|} ;
+  Some {|foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+|} ;
+  None ;
+  Some "foo\n" ;
+  Some "foo\n" ]
+
+let basic_diffs =
+  let hdr =
+    Printf.sprintf
+{|--- a%s2019-03-10 16:48:51.826103000 +0100
++++ b%s2019-03-10 16:48:54.373352000 +0100
+|} "\t" "\t"
+  in
+  [
+    hdr ^
+{|@@ -1 +1 @@
+-foo
++foobar
+|} ;
+    hdr ^
+{|@@ -2,7 +2,7 @@
+ bar
+ baz
+ boo
+-foo
++foo2
+ bar
+ baz
+ boo
+|} ;
+    hdr ^
+{|@@ -1,5 +1,5 @@
+ foo
+-bar
++bar2
+ baz
+ boo
+ foo
+@@ -8,4 +8,4 @@
+ boo
+ foo
+ bar
+-baz
++baz3
+|} ;
+    hdr ^
+{|@@ -1,6 +1,7 @@
+ foo
+ foo
+ foo
++foo3
+ foo
+ foo
+ foo
+@@ -9,6 +10,7 @@
+ foo
+ foo
+ foo
++foo5
+ foo
+ foo
+ foo
+@@ -31,6 +33,11 @@
+ foo
+ foo
+ foo
++bar
+ foo
+ foo
+ foo
++foo
++foo
++foo
++bar2
+|} ;
+{|--- /dev/null
++++ b
+@@ -0,0 +1 @@
++foo
+|} ;
+{|--- a
++++ /dev/null
+@@ -1 +0,0 @@
+-foo
+|} ;
+{|--- a
++++ b
+@@ -1 +1,2 @@
+ foo
++foo
+|}
+  ]
+
+let basic_hunks =
+  let open Patch in
+  let hunk1 = [ { mine_start = 0 ; mine_len = 1 ; mine = ["foo"] ;
+                  their_start = 0 ; their_len = 1 ; their = ["foobar"] } ]
+  in
+  let diff = { operation = Rename ("a", "b") ; hunks = hunk1 ; mine_no_nl = false ; their_no_nl = false } in
+  let hunk2 =
+    [ { mine_start = 1 ; mine_len = 7 ; mine = [ "bar" ; "baz" ; "boo" ; "foo" ; "bar" ; "baz" ; "boo" ] ;
+        their_start = 1 ; their_len = 7 ; their = [ "bar" ; "baz" ; "boo" ; "foo2" ; "bar" ; "baz" ; "boo" ] } ]
+  in
+  let hunk3 = [
+    { mine_start = 0 ; mine_len = 5 ; mine = [ "foo" ; "bar" ; "baz" ; "boo" ; "foo" ] ;
+      their_start = 0 ; their_len = 5 ; their = [ "foo" ; "bar2" ; "baz" ; "boo" ; "foo" ] } ;
+    { mine_start = 7 ; mine_len = 4 ; mine = [ "boo" ; "foo" ; "bar" ; "baz" ] ;
+      their_start = 7 ; their_len = 4 ; their = [ "boo" ; "foo" ; "bar" ; "baz3" ] }
+  ] in
+  let hunk4 = [
+    { mine_start = 0 ; mine_len = 6 ; mine = [ "foo" ; "foo" ; "foo" ; "foo" ; "foo" ; "foo" ] ;
+      their_start = 0 ; their_len = 7 ; their = [ "foo" ; "foo" ; "foo" ; "foo3" ; "foo" ; "foo" ; "foo" ] } ;
+    { mine_start = 8 ; mine_len = 6 ; mine = [ "foo" ; "foo" ; "foo" ; "foo" ; "foo" ; "foo" ] ;
+      their_start = 9 ; their_len = 7 ; their = [ "foo" ; "foo" ; "foo" ; "foo5" ; "foo" ; "foo" ; "foo" ] } ;
+    { mine_start = 30 ; mine_len = 6 ; mine = [ "foo" ; "foo" ; "foo" ; "foo" ; "foo" ; "foo" ] ;
+      their_start = 32 ; their_len = 11 ; their = [ "foo" ; "foo" ; "foo" ; "bar" ; "foo" ; "foo" ; "foo" ; "foo" ; "foo" ; "foo" ; "bar2" ] }
+  ] in
+  let hunk5= [
+    { mine_start = 0 ; mine_len = 0 ; mine = [] ;
+      their_start = 0 ; their_len = 1 ; their = [ "foo" ] }
+  ] in
+  let diff5 = { diff with operation = Create "b" ; hunks = hunk5 } in
+  let hunk6 = [
+    { mine_start = 0 ; mine_len = 1 ; mine = [ "foo" ] ;
+      their_start = 0 ; their_len = 0 ; their = [ ] }
+  ] in
+  let diff6 = { diff with operation = Delete "a" ; hunks = hunk6 } in
+  let hunk7 = [
+    { mine_start = 0 ; mine_len = 1 ; mine = [ "foo" ] ;
+      their_start = 0 ; their_len = 2 ; their = [ "foo" ; "foo" ] }
+  ] in
+  let diff7 = { diff with operation = Rename ("a", "b") ; hunks = hunk7 } in
+  List.map (fun d -> [ d ])
+    [
+      diff ;
+      { diff with hunks = hunk2 } ;
+      { diff with hunks = hunk3 } ;
+      { diff with hunks = hunk4 } ;
+      diff5 ;
+      diff6 ;
+      diff7 ;
+    ]
+
+let basic_app = [
+  Some "foobar\n" ;
+  Some {|foo
+bar
+baz
+boo
+foo2
+bar
+baz
+boo
+|} ;
+  Some {|foo
+bar2
+baz
+boo
+foo
+bar
+bar
+boo
+foo
+bar
+baz3
+|} ;
+  Some {|foo
+foo
+foo
+foo3
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo5
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+foo
+bar
+foo
+foo
+foo
+foo
+foo
+foo
+bar2
+|} ;
+ Some {|foo
+|} ;
+  None ;
+  Some {|foo
+foo
+|}
+]
+
+let basic_parse diff exp () =
+  let diffs = Patch.to_diffs diff in
+  Alcotest.(check (list test_t) __LOC__ exp diffs)
+
+let parse_diffs =
+  List.mapi (fun idx (diff, exp) ->
+      "basic" ^ string_of_int idx, `Quick, basic_parse diff exp)
+    (List.combine basic_diffs basic_hunks)
+
+let basic_apply file diff exp () =
+  match Patch.to_diffs diff with
+  | [ diff ] ->
+    let res = Patch.patch file diff in
+    Alcotest.(check (option string) __LOC__ exp res)
+  | _ -> Alcotest.fail "expected one"
+
+let apply_diffs =
+  List.mapi (fun idx (exp, (data, diff)) ->
+      "basic" ^ string_of_int idx, `Quick, basic_apply data diff exp)
+    (List.combine basic_app (List.combine basic_files basic_diffs))
+
+(* a diff with multiple files to patch, with each of the four kinds:
+   rename, delete, create, edit *)
+let multi_diff = {|
+--- foo
++++ bar
+@@ -1 +1 @@
+-bar
++foobar
+--- foobar
++++ /dev/null
+@@ -1 +0,0 @@
+-baz
+--- /dev/null
++++ baz
+@@ -0,0 +1 @@
++baz
+\ No newline at end of file
+--- foobarbaz
++++ foobarbaz
+@@ -1 +1 @@
+-foobarbaz
++foobar
+|}
+
+let multi_hunks =
+  let open Patch in
+  let hunk1 = [ { mine_start = 0 ; mine_len = 1 ; mine = ["bar"] ;
+                  their_start = 0 ; their_len = 1 ; their = ["foobar"] } ]
+  in
+  let diff1 = { operation = Rename ("foo", "bar") ; hunks = hunk1 ; mine_no_nl = false ; their_no_nl = false } in
+  let hunk2 =
+    [ { mine_start = 0 ; mine_len = 1 ; mine = [ "baz" ] ;
+        their_start = 0 ; their_len = 0 ; their = [] } ]
+  in
+  let diff2 = { operation = Delete "foobar" ; hunks = hunk2 ; mine_no_nl = false ; their_no_nl = false } in
+  let hunk3 = [
+    { mine_start = 0 ; mine_len = 0 ; mine = [ ] ;
+      their_start = 0 ; their_len = 1 ; their = [ "baz" ] }
+  ] in
+  let diff3 = { operation = Create "baz" ; hunks = hunk3 ;  mine_no_nl = false ; their_no_nl = true } in
+  let hunk4 = [
+    { mine_start = 0 ; mine_len = 1 ; mine = [ "foobarbaz" ] ;
+      their_start = 0 ; their_len = 1 ; their = [ "foobar" ] }
+  ] in
+  let diff4 = { operation = Edit "foobarbaz" ; hunks = hunk4 ;  mine_no_nl = false ; their_no_nl = false } in
+  [ diff1 ; diff2 ; diff3 ; diff4 ]
+
+let multi_files = [ Some "bar" ; Some "baz" ; None ; Some "foobarbaz" ]
+
+let multi_exp = [ Some "foobar" ; None ; Some "baz" ; Some "foobar" ]
+
+let multi_apply () =
+  let diffs = Patch.to_diffs multi_diff in
+  Alcotest.(check int __LOC__ (List.length multi_files) (List.length diffs));
+  Alcotest.(check int __LOC__ (List.length multi_exp) (List.length diffs));
+  List.iter2 (fun diff (input, expected) ->
+      let res = Patch.patch input diff in
+      Alcotest.(check (option string) __LOC__ expected res))
+    diffs (List.combine multi_files multi_exp)
+
+let multi_diffs = [
+  "multi parse", `Quick, basic_parse multi_diff multi_hunks ;
+  "multi apply", `Quick, multi_apply ;
+]
+
+let data = "data/"
+
+let read file =
+  let filename = data ^ file in
+  let size = Unix.(stat filename).st_size in
+  let buf = Bytes.create size in
+  let fd = Unix.openfile filename [ Unix.O_RDONLY ] 0 in
+  let res = Unix.read fd buf 0 size in
+  assert (res = size) ;
+  Unix.close fd ;
+  Bytes.unsafe_to_string buf
+
+let opt_read file = try Some (read file) with Unix.Unix_error _ -> None
+
+let op_test = Alcotest.testable (Patch.pp_operation ~git:false) Patch.operation_eq
+
+let parse_real_diff_header file hdr () =
+  let data = read (file ^ ".diff") in
+  let diffs = Patch.to_diffs data in
+  Alcotest.(check int __LOC__ 1 (List.length diffs));
+  Alcotest.check op_test __LOC__ hdr (List.hd diffs).Patch.operation
+
+let parse_real_diff_headers =
+  List.map (fun (file, hdr) ->
+      "parsing " ^ file ^ ".diff", `Quick, parse_real_diff_header file hdr)
+    [ "first", Patch.Rename ("first.old", "first.new") ;
+      "create1", Patch.Create "a/create1" ;
+      "git1", Patch.Create "git1.new" ;
+      "git2", Patch.Rename_only ("git2.old", "git2.new") ;
+      "git3", Patch.Rename ("git3.old", "git3.new") ;
+      "git4", Patch.Delete "git4.old"
+    ]
+
+let regression_test name () =
+  let old = opt_read (name ^ ".old") in
+  let diff = read (name ^ ".diff") in
+  let exp = opt_read (name ^ ".new") in
+  match Patch.to_diffs diff with
+  | [ diff ] ->
+    let res = Patch.patch old diff in
+    Alcotest.(check (option string) __LOC__ exp res)
+  | ds -> Alcotest.fail ("expected one, found " ^ string_of_int (List.length ds))
+
+module S = Set.Make(String)
+
+let drop_ext str =
+  try
+    let idx = String.rindex str '.' in
+    String.sub str 0 idx
+  with
+  | Not_found -> str
+
+let regression_diffs =
+  let collect_dir dir =
+    let open Unix in
+    let dh = opendir dir in
+    let next () = try Some (readdir dh) with End_of_file -> None in
+    let rec doone acc = function
+      | Some "." | Some ".." -> doone acc (next ())
+      | Some s -> doone (s :: acc) (next ())
+      | None -> acc
+    in
+    let res = doone [] (next ()) in
+    closedir dh ;
+    res
+  in
+  let files = collect_dir data in
+  let tests = List.fold_left (fun acc file -> S.add (drop_ext file) acc) S.empty files in
+  List.map (fun test -> "regression " ^ test, `Quick, regression_test test) (S.elements tests)
+
+let tests = [
+  "parse", parse_diffs ;
+  "apply", apply_diffs ;
+  "multiple", multi_diffs ;
+  "parse real diffs", parse_real_diff_headers ;
+  "regression", regression_diffs ;
+]
+
+let () =
+  Alcotest.run "Patch tests" tests

 diff --git a/dir1/file.txt b/dir2/file.txt
index dfd0d1e..ce59064 100644
--- a/dir1/file.txt
+++ b/dir2/file.txt
@@ -1 +1 @@
-This is the original content.
+This is the modified content.
diff --git a/dir2/new_diff.diff b/dir2/new_diff.diff
new file mode 100644
index 0000000..e69de29

diff --git a/dir1/file.txt b/dir2/file.txt
index dfd0d1e..50e0cc9 100644
--- a/dir1/file.txt
+++ b/dir2/file.txt
@@ -1 +1,2 @@
 This is the original content.
+Here is some additional line.
diff --git a/dir2/new_diff.diff b/dir2/new_diff.diff
new file mode 100644
index 0000000..e69de29

diff --git a/dir1/file.txt b/dir2/file.txt
index dfd0d1e..cf5dea7 100644
--- a/dir1/file.txt
+++ b/dir2/file.txt
@@ -1 +1,2 @@
-This is the original content.
+Here is some additional line.
+Deleted line 1 and added this.

diff --git a/dir2/file.txt b/dir2/file.txt
new file mode 100644
index 0000000..01a59b0
--- /dev/null
+++ b/dir2/file.txt
@@ -0,0 +1 @@
+lorem ipsum

diff --git a/dir1/file.txt b/dir1/file.txt
deleted file mode 100644
index 7b57bd2..0000000
--- a/dir1/file.txt
+++ /dev/null
@@ -1 +0,0 @@
-some text

diff --git a/dir1/file.txt b/dir2/new_file.txt
similarity index 100%
rename from dir1/file.txt
rename to dir2/new_file.txt

diff --git a/dir1/file.txt b/dir1/file.txt
deleted file mode 100644
index 7b57bd2..0000000
--- a/dir1/file.txt
+++ /dev/null
@@ -1 +0,0 @@
-some text
diff --git a/dir2/sample.txt b/dir2/sample.txt
new file mode 100644
index 0000000..9809dd1
--- /dev/null
+++ b/dir2/sample.txt
@@ -0,0 +1,2 @@
+some text
+lorem ipsum

diff --git a/dir1/file.txt b/dir2/file.txt
index e69de29..eee417f 100644
--- a/dir1/file.txt
+++ b/dir2/file.txt
@@ -0,0 +1 @@
+new text